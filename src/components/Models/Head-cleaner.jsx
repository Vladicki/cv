/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 head-cleaner.glb
*/

import React, { useState, useEffect, useRef } from 'react'; // Import useState, useEffect, useRef
import { useGLTF } from '@react-three/drei';
import { Decal, useTexture } from '@react-three/drei';

export function Head(props) {
    const { nodes, materials } = useGLTF('/models/head-cleaner.glb');
    const decalTexture = useTexture('/models/eyes_closed.png');

    // State to track if the mouse button is currently held down on the mesh
    const [isHolding, setIsHolding] = useState(false);
    // State to track if the decal is currently in a blinking phase
    const [isBlinking, setIsBlinking] = useState(false);

    // Define the base opacity values based on your last provided code
    // When held down, opacity is 1 (visible)
    const opacityWhenHeld = 1;
    // When not held down, opacity is 0 (invisible)
    const opacityWhenNotHeld = 0;

    // Determine the current opacity based on the 'isBlinking' and 'isHolding' states
    // Blinking effect takes precedence
    const currentDecalOpacity = isBlinking ? 1 // When blinking, opacity is 0 (invisible)
        : isHolding ? opacityWhenHeld // If holding, use opacityWhenHeld (1)
            : opacityWhenNotHeld; // Otherwise (not blinking, not holding), use opacityWhenNotHeld (0)

    // Ref to store the timeout ID so we can clear it
    const blinkTimeoutRef = useRef(null);

    // Effect for the random blinking
    useEffect(() => {
        const scheduleBlink = () => {
            // Generate a random delay between 7 and 10 seconds (7000ms to 10000ms)
            const randomDelay = Math.random() * (10000 - 5000) + 5000;

            blinkTimeoutRef.current = setTimeout(() => {
                // Start the blink (set opacity to 0)
                setIsBlinking(true);

                // Schedule turning off the blink after 0.5 seconds
                setTimeout(() => {
                    setIsBlinking(false);
                    // After turning off, schedule the next blink
                    scheduleBlink();
                }, 300); // 0.5 seconds blink duration

            }, randomDelay);
        };

        // Start the first blink cycle
        scheduleBlink();

        // Cleanup function: Clear the timeout when the component unmounts
        return () => {
            if (blinkTimeoutRef.current) {
                clearTimeout(blinkTimeoutRef.current);
            }
        };
    }, []); // Empty dependency array means this effect runs once on mount and cleans up on unmount

    // Function to handle pointer down event (mouse button pressed)
    const handlePointerDown = (event) => {
        setIsHolding(true);
    };

    // Function to handle pointer up event (mouse button released)
    const handlePointerUp = (event) => {
        setIsHolding(false);
    };

    return (
        <group {...props} dispose={null}>
            <mesh
                geometry={nodes.FBHead.geometry}
                material={materials.chat}
                onPointerDown={handlePointerDown} // Attach onPointerDown
                onPointerUp={handlePointerUp}     // Attach onPointerUp
            >
                <Decal
                    transparent // Essential for opacity to work
                    depthTest={true}
                    depthWrite={true}
                    // debug // Makes "bounding box" of the decal visible
                    position={[-0.01, 0.36, 1]} // adjust decal position (y+ is up)
                    rotation={[Math.PI, Math.PI, Math.PI]} // adjust decal rotation
                    scale={[1.2, 0.32, 1]} // adjust decal size (fixed horizontal stretch)
                    polygonOffset
                    polygonOffsetFactor={-4}
                    map={decalTexture}
                >
                    {/* This is where you apply the opacity */}
                    <meshBasicMaterial
                        map={decalTexture}
                        transparent={true} // Must be true for opacity to take effect
                        opacity={currentDecalOpacity} // Use the state-driven opacity
                        polygonOffset={true} // Inherit polygonOffset from parent Decal
                        polygonOffsetFactor={-4} // Inherit polygonOffsetFactor from parent Decal
                    />
                </Decal>
            </mesh>
        </group>
    );
}

useGLTF.preload('/models/head-cleaner.glb');
