/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 head-cleaner.glb
*/

import React, { useState, useEffect, useRef } from 'react';
import { useGLTF } from '@react-three/drei';
import { Decal, useTexture } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import * as THREE from 'three';
import gsap from 'gsap';

// A simple array of quotes for the techDescription
const quotes = [
    "If only there were an employee",
    "God, the WORK, sounds good",
    "If only they knew how good my promts are",
    "Should've said i use Arch",
    "Why spinning donuts, can secure a job position",
    "Wish i were a LLM",
];

export function Head({ setTechDescription, ...props }) {
    const { nodes, materials } = useGLTF('/models/head-cleaner.glb');
    const decalTexture = useTexture('/models/eyes_closed.png');

    // State for pointer interaction and blinking (unchanged)
    const [isHolding, setIsHolding] = useState(false);
    const [isBlinking, setIsBlinking] = useState(false);

    // Opacity values (unchanged)
    const defaultVisibleOpacity = 0;
    const heldTransparentOpacity = 1;
    const blinkInvisibleOpacity = 1;

    // Refs for 3D objects and animation control
    const headRef = useRef();
    const blinkTimeoutRef = useRef(null);

    // Refs for head rotation
    const mouse = useRef(new THREE.Vector2());
    const targetRotationRef = useRef({ x: 0, y: 0 });
    const currentRotationRef = useRef({ x: 0, y: 0 });
    const initialHeadEulerRef = useRef(new THREE.Euler());

    // --- Mouse Movement Handler ---
    useEffect(() => {
        const handleMouseMove = (event) => {
            mouse.current.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.current.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const maxLookUp = Math.PI / 20;
            const maxLookDown = Math.PI / 4;
            const maxLookSideways = Math.PI / 6;

            let rotationX;
            if (mouse.current.y < 0) {
                rotationX = -mouse.current.y * maxLookUp;
            } else {
                rotationX = -mouse.current.y * maxLookDown;
            }

            const rotationY = mouse.current.x * maxLookSideways;

            targetRotationRef.current.x = rotationX;
            targetRotationRef.current.y = rotationY;
        };

        window.addEventListener('mousemove', handleMouseMove);

        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
        };
    }, []);

    // --- Capture Initial Head Rotation on Mount ---
    useEffect(() => {
        const timeoutId = setTimeout(() => {
            if (headRef.current) {
                initialHeadEulerRef.current.setFromQuaternion(headRef.current.quaternion, 'YXZ');
                currentRotationRef.current.x = 0;
                currentRotationRef.current.y = 0;
            }
        }, 50);

        return () => clearTimeout(timeoutId);
    }, []);

    // --- Head Tracking Logic (runs on every frame) ---
    useFrame(() => {
        if (headRef.current) {
            currentRotationRef.current.x = gsap.utils.interpolate(
                currentRotationRef.current.x,
                targetRotationRef.current.x,
                0.2
            );
            currentRotationRef.current.y = gsap.utils.interpolate(
                currentRotationRef.current.y,
                targetRotationRef.current.y,
                0.2
            );
            headRef.current.rotation.x = initialHeadEulerRef.current.x + currentRotationRef.current.x;
            headRef.current.rotation.y = initialHeadEulerRef.current.y + currentRotationRef.current.y;
            headRef.current.rotation.z = initialHeadEulerRef.current.z;
        }
    });

    // --- Blinking Effect (unchanged - separate logic) ---
    useEffect(() => {
        const scheduleBlink = () => {
            const randomDelay = Math.random() * (10000 - 7000) + 7000;

            blinkTimeoutRef.current = setTimeout(() => {
                setIsBlinking(true);
                setTimeout(() => {
                    setIsBlinking(false);
                    scheduleBlink();
                }, 500);
            }, randomDelay);
        };

        scheduleBlink();

        return () => {
            if (blinkTimeoutRef.current) {
                clearTimeout(blinkTimeoutRef.current);
            }
        };
    }, []);

    // --- Decal Opacity Calculation (unchanged) ---
    const currentDecalOpacity = isBlinking
        ? blinkInvisibleOpacity
        : isHolding
            ? heldTransparentOpacity
            : defaultVisibleOpacity;

    // --- Pointer Handlers (unchanged) ---
    const handlePointerDown = () => {
        setIsHolding(true);
    };

    const handlePointerUp = () => {
        setIsHolding(false);
    };

    // --- NEW Pointer Handlers for Hover Effects ---
    const handlePointerOver = () => {
        // Select a random quote
        const randomIndex = Math.floor(Math.random() * quotes.length);
        setTechDescription(quotes[randomIndex]);
    };

    const handlePointerOut = () => {
        // Clear the techDescription when the cursor leaves
        // setTechDescription("");
    };

    return (
        <group {...props} dispose={null} ref={headRef}>
            <mesh
                geometry={nodes.FBHead.geometry}
                material={materials.chat}
                onPointerDown={handlePointerDown}
                onPointerUp={handlePointerUp}
                onPointerOver={handlePointerOver} // NEW: Add hover event
                onPointerOut={handlePointerOut}   // NEW: Add hover out event
            >
                <Decal
                    transparent
                    depthTest={true}
                    depthWrite={true}
                    position={[-0.01, 0.36, 1]}
                    rotation={[Math.PI, Math.PI, Math.PI]}
                    scale={[1.2, 0.32, 1]}
                    polygonOffset
                    polygonOffsetFactor={-4}
                    map={decalTexture}
                >
                    <meshBasicMaterial
                        map={decalTexture}
                        transparent={true}
                        opacity={currentDecalOpacity}
                        polygonOffset={true}
                        polygonOffsetFactor={-4}
                    />
                </Decal>
            </mesh>
        </group>
    );
}

useGLTF.preload('/models/head-cleaner.glb');
