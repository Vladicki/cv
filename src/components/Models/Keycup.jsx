/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 keycup.glb
*/

import * as THREE from 'three'
import React, { forwardRef, useMemo, useState, useEffect, useRef } from 'react'
import { useCursor, useGLTF } from '@react-three/drei'
import { Decal, Float, useTexture } from '@react-three/drei'
import gsap from 'gsap';


export const Keycup = React.forwardRef(function Keycup({
    pointerOutTimeoutRef,
    floatSpeed = 0,
    floatRotationIntensity = 0,
    floatFloatIntensity = 0,
    sceneType, // 'hero' or 'numpad' to determine behavior
    ...props
}, ref) {
    const color = props.color || '#ffffff'
    const { imgURL, setTechDescription, text, techDesc, ...restProps } = props;

    const [decalTexture] = useTexture([imgURL]);
    // Removed 'animations' from destructuring useGLTF as we're now using GSAP for these specific animations.
    const { nodes, materials } = useGLTF('models/keycup.glb');

    // groupAnimRef will be used for the numpad press animation (animating the overall group's position).
    // This is also the ref that the parent component will receive via useImperativeHandle.
    const groupAnimRef = useRef();
    // meshRef will be used for the hero scale animation (animating the individual mesh's scale).
    const meshRef = useRef();

    // useImperativeHandle makes the 'ref' prop passed from the parent point to this groupAnimRef.
    // This allows parents to access the group (e.g., for positioning).
    React.useImperativeHandle(ref, () => groupAnimRef.current);

    const [hovered, hover] = useState(false);
    useCursor(hovered); // Changes cursor based on hover state

    const lambertMaterial = useMemo(
        () => new THREE.MeshLambertMaterial({ color }),
        [color]
    );

    // Set initial scale for the mesh for the 'hero' type when the component mounts.
    // This ensures GSAP has a consistent starting point.
    useEffect(() => {
        if (meshRef.current && sceneType === 'hero') {
            meshRef.current.scale.set(1.233, 0.73, 1.233);
        }
    }, [sceneType]); // Dependency on sceneType ensures this runs when sceneType changes (including initial mount).

    // Cleanup the global pointer out timeout when this component unmounts to prevent memory leaks.
    useEffect(() => {
        return () => {
            if (pointerOutTimeoutRef.current) {
                clearTimeout(pointerOutTimeoutRef.current);
                pointerOutTimeoutRef.current = null;
            }
        };
    }, [pointerOutTimeoutRef]);

    /**
     * Handles the pointer entering a Keycup.
     * Displays the technical description and sets cursor state.
     * @param {THREE.Event} event - The pointer event object from R3F.
     */
    const handlePointerOver = (event) => {
        event.stopPropagation(); // Prevent the event from bubbling up to parent elements.

        // Ensure this interaction is for the directly hovered object.
        if (event.intersections && event.intersections.length > 0 && event.intersections[0].object === event.object) {
            // Clear any pending timeout that would hide the tech description, as we're still hovering.
            if (pointerOutTimeoutRef.current) {
                clearTimeout(pointerOutTimeoutRef.current);
                pointerOutTimeoutRef.current = null;
            }

            hover(true); // Update hover state for cursor feedback.
            setTechDescription(techDesc); // Display the description for the current tech item.
        }
    };

    /**
     * Handles the pointer leaving a Keycup.
     * Schedules the technical description to be cleared after a delay.
     * @param {THREE.Event} event - The pointer event object from R3F.
     */
    const handlePointerOut = (event) => {
        event.stopPropagation(); // Prevent the event from bubbling up.
        hover(false); // Clear hover state.

        // Schedule the description to be cleared after a delay.
        pointerOutTimeoutRef.current = setTimeout(() => {
            setTechDescription(""); // Clear the description after the timeout.
        }, 2000); // 2-second delay.
    };

    /**
     * Handles the click event on a Keycup.
     * Conditionally performs a scale change (Hero) or a 'press' animation (Numpad) using GSAP.
     * @param {THREE.Event} event - The pointer event object from R3F.
     */
    const handleClick = (event) => {
        event.stopPropagation(); // Prevent the event from bubbling up.

        // --- Conditional Logic based on sceneType ---
        if (sceneType === 'hero') {
            // Animate scale smoothly for the 'hero' keycup using GSAP.
            if (meshRef.current) {
                // Determine target scale based on the current scale to toggle between two states.
                const currentScaleX = meshRef.current.scale.x;
                const targetScaleFactor = currentScaleX > 1.3 ? 1.233 : 1.5; // Toggle between default and enlarged.
                // Y-scale remains constant for this animation.
                const targetScaleY = 0.73;

                // Use 'window.gsap' or 'gsap' directly if it's globally available.
                (window.gsap || gsap).to(meshRef.current.scale, {
                    x: targetScaleFactor,
                    y: targetScaleY,
                    z: targetScaleFactor,
                    duration: 0.3, // Smooth animation duration.
                    ease: "power2.out" // Easing function for a natural feel.
                });
                console.log('Keycup scaled (Hero, GSAP scale):', text);
            } else {
                console.warn("meshRef.current is not available for Hero scale animation.");
            }
        } else if (sceneType === 'numpad') {
            // Simulate a 'press' animation by moving the entire group down and then back up using GSAP.
            if (groupAnimRef.current) {
                const initialY = groupAnimRef.current.position.y;
                const pressDepth = -0.15; // Define how deep the key presses. Adjust this value as needed.

                // Create a GSAP timeline to sequence the 'press down' and 'return up' animations.
                // Use 'window.gsap' or 'gsap' directly if it's globally available.
                (window.gsap || gsap).timeline()
                    .to(groupAnimRef.current.position, {
                        y: initialY + pressDepth, // Move down
                        duration: 0.12, // Quick press down duration.
                        ease: "power1.out" // Easing for the press down.
                    })
                    .to(groupAnimRef.current.position, {
                        y: initialY, // Return to original Y position
                        duration: 0.2, // Slower return up duration.
                        ease: "elastic.out(1, 0.5)" // Elastic ease for a subtle bounce effect, making it feel more realistic.
                    });
                console.log('Keycup pressed (Numpad, GSAP animation played):', text);
            } else {
                console.warn("groupAnimRef.current is not available for Numpad press animation.");
            }
        }
        // --- End Conditional Logic ---
    };

    return (
        // Attach groupAnimRef to the top-level <group> element of the GLTF model.
        // This group's position will be animated for the 'numpad' press effect.
        <group ref={groupAnimRef} {...props} dispose={null}>
            {/* The Float component's properties are now conditional based on sceneType.
                It will only apply floating motion if sceneType is 'hero'. */}
            <Float
                speed={sceneType === 'hero' ? floatSpeed : 0}
                rotationIntensity={sceneType === 'hero' ? floatRotationIntensity : 0}
                floatIntensity={sceneType === 'hero' ? floatFloatIntensity : 0}
            >
                <mesh
                    ref={meshRef} // Attach meshRef here to allow GSAP to directly control its scale.
                    geometry={nodes.Cube001.geometry}
                    material={lambertMaterial}
                    // The initial scale for the mesh for both scene types.
                    // For 'hero', GSAP will animate this scale on click.
                    // For 'numpad', the position of the parent groupAnimRef is animated, not the mesh's scale.
                    scale={[1.233, 0.73, 1.233]}
                    onClick={handleClick}
                    onPointerOver={handlePointerOver}
                    onPointerOut={handlePointerOut}
                >
                    <Decal
                        transparent
                        depthTest={true}
                        depthWrite={true}
                        position={[0, 0.9, 0]}
                        rotation={[Math.PI / 2, Math.PI, 0]}
                        scale={1}
                        polygonOffset
                        polygonOffsetFactor={-4}
                        map={decalTexture}
                        flatShading
                    />
                </mesh>
            </Float>
        </group>
    );
});

// Preload the GLTF model for better performance, regardless of whether animations from it are used.
useGLTF.preload('models/keycup.glb');
