/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 keycup.glb
*/

import * as THREE from 'three'
import React, { forwardRef, useMemo, useState, useEffect, useRef } from 'react'
import { useCursor, useGLTF, useAnimations } from '@react-three/drei'
import { Decal, Float, useTexture } from '@react-three/drei'
// No GSAP import needed if we are just toggling `clicked` state for scale,
// or playing GLTF animations.

export const Keycup = React.forwardRef(function Keycup({
    pointerOutTimeoutRef,
    floatSpeed = 0,
    floatRotationIntensity = 0,
    floatFloatIntensity = 0,
    sceneType, // NEW: 'hero' or 'numpad' to determine behavior
    // initialScale prop is removed as per "keep it like it is" for scale
    ...props
}, ref) {
    const color = props.color || '#ffffff'
    const { imgURL, setTechDescription, text, techDesc, ...restProps } = props;

    const [decalTexture] = useTexture([imgURL]);
    const { nodes, materials, animations } = useGLTF('models/keycup.glb');

    // This groupRef is where the animations are actually applied.
    // It must be attached to the <group> that is the root of your GLTF model's hierarchy.
    const groupAnimRef = useRef();

    // useImperativeHandle makes the 'ref' prop passed from the parent point to this groupAnimRef.
    // So, parent's ref will access the group which holds animations.
    React.useImperativeHandle(ref, () => groupAnimRef.current);

    // useAnimations hook needs the groupRef to control animations
    const { actions, mixer } = useAnimations(animations, groupAnimRef);

    const [hovered, hover] = useState(false);
    // 'clicked' state will be used *only* for the Hero section's scaling behavior.
    const [clicked, setClicked] = useState(false);
    useCursor(hovered); // Changes cursor based on hover state

    const lambertMaterial = useMemo(
        () => new THREE.MeshLambertMaterial({ color }),
        [color]
    );

    // Ensure the mixer is properly initialized and does not auto-play animations.
    // This effect runs once on mount.
    useEffect(() => {
        if (mixer) {
            mixer.stopAllAction(); // Stop any animations that might auto-play on load
        }
    }, [mixer]); // Dependency on mixer ensures it runs when mixer is available

    // Cleanup the global pointer out timeout when this component unmounts
    useEffect(() => {
        return () => {
            if (pointerOutTimeoutRef.current) {
                clearTimeout(pointerOutTimeoutRef.current);
                pointerOutTimeoutRef.current = null;
            }
        };
    }, [pointerOutTimeoutRef]);

    /**
     * Handles the pointer entering a Keycup.
     * Sets tech description and cursor, does NOT trigger animations here.
     * @param {THREE.Event} event - The pointer event object from R3F.
     */
    const handlePointerOver = (event) => {
        event.stopPropagation(); // Prevent the event from bubbling up to parent elements

        // Ensure this is the closest intersected object to avoid triggering for hidden items
        if (event.intersections && event.intersections.length > 0 && event.intersections[0].object === event.object) {
            // Clear any pending timeout that would hide the tech description
            if (pointerOutTimeoutRef.current) {
                clearTimeout(pointerOutTimeoutRef.current);
                pointerOutTimeoutRef.current = null;
            }

            hover(true); // Update hover state for cursor feedback
            setTechDescription(techDesc); // Display the description for the current tech item
        }
    };

    /**
     * Handles the pointer leaving a Keycup.
     * Schedules the tech description to be cleared after a delay.
     * @param {THREE.Event} event - The pointer event object from R3F.
     */
    const handlePointerOut = (event) => {
        event.stopPropagation(); // Prevent the event from bubbling up
        hover(false); // Clear hover state

        // Schedule the description to be cleared after a delay.
        pointerOutTimeoutRef.current = setTimeout(() => {
            setTechDescription(""); // Clear the description after the timeout
        }, 2000); // 2-second delay
    };

    /**
     * Handles the click event on a Keycup.
     * Conditionally performs scale change (Hero) or 'press' animation (Numpad).
     * @param {THREE.Event} event - The pointer event object from R3F.
     */
    const handleClick = (event) => {
        event.stopPropagation(); // Prevent the event from bubbling up

        // --- Conditional Logic based on sceneType ---
        if (sceneType === 'hero') {
            // Toggle clicked state for simple scale change based on `scale={clicked ? ... : ...}`
            setClicked(prev => !prev);
            console.log('Keycup scaled (Hero, state toggle):', text);
        } else if (sceneType === 'numpad') {
            // Play the 'press' animation only if in 'numpad' section and animation exists
            const pressAction = actions.press; // Access the specific animation action by name

            if (pressAction) {
                console.log("playing animation for:", text, "Action:", pressAction);
                pressAction
                    .reset()           // Reset animation to its start frame
                    .setLoop(THREE.LoopOnce, 1) // Play only once (1 repetition after initial play)
                    .clampWhenFinished = true; // Stay on the last frame when finished

                pressAction.play(); // Start the animation
                // You might need a short timeout here if the animation is too fast
                // to see or if it needs to reverse after playing.
                // For a single "press" action, this should be fine.
                console.log('Keycup pressed (Numpad, animation played):', text);
            } else {
                console.warn(`No 'press' animation found for ${text}. Available actions:`, Object.keys(actions));
            }
        }
        // --- End Conditional Logic ---
    };

    return (
        // Attach groupAnimRef to the top-level <group> element.
        // This group is what `useAnimations` will animate.
        // The `ref` prop passed from parent will also point to this group.
        <group ref={groupAnimRef} {...props} dispose={null}>
            {/* Float component's properties are now conditional based on sceneType */}
            <Float
                // Floating only enabled in 'hero' sceneType, otherwise set to 0 (no float)
                speed={sceneType === 'hero' ? floatSpeed : 0}
                rotationIntensity={sceneType === 'hero' ? floatRotationIntensity : 0}
                floatIntensity={sceneType === 'hero' ? floatFloatIntensity : 0}
            >
                <mesh
                    geometry={nodes.Cube001.geometry}
                    // Do NOT use ref={ref} here. `ref` is already pointing to `groupAnimRef`
                    // via useImperativeHandle on the parent <group>.
                    // This mesh will be implicitly animated by its parent group if the animation
                    // targets the group or its children.
                    material={lambertMaterial}
                    // Scale controlled by `clicked` state only for 'hero' scene
                    scale={
                        sceneType === "hero"
                            ? (clicked ? [1.5, 0.73, 1.5] : [1.233, 0.73, 1.233])
                            : [1.233, 0.73, 1.233] // Numpad stays default (animation handles press visual)
                    }
                    onClick={handleClick}
                    onPointerOver={handlePointerOver}
                    onPointerOut={handlePointerOut}
                >
                    <Decal
                        transparent
                        depthTest={true}
                        depthWrite={true}
                        position={[0, 0.9, 0]}
                        rotation={[Math.PI / 2, Math.PI, 0]}
                        scale={1}
                        polygonOffset
                        polygonOffsetFactor={-4}
                        map={decalTexture}
                        flatShading
                    />
                </mesh>
            </Float>
        </group>
    );
});

// Preload the GLTF model for better performance
useGLTF.preload('models/keycup.glb');
